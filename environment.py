### DO NOT EDIT THIS FILE ###

import arcade
import numpy as np

import settings


# The Environment class, which defines the dynamics of the world
class Environment:

    # Initialisation function to create a new environment
    def __init__(self):

        # Set the obstacle's state and size
        self.obstacle_state = np.array([0.65, 0.65])
        self.obstacle_size = np.array([0.1, 0.1])
        # Set the goal's state
        self.goal_state = np.array([0.8, 0.8])

    # Function to draw the environment onto the screen
    def draw(self):

        # Draw the obstacle onto the screen
        arcade.draw_rectangle_filled(settings.SCREEN_SIZE * self.obstacle_state[0],
                                     settings.SCREEN_SIZE * self.obstacle_state[1],
                                     settings.SCREEN_SIZE * self.obstacle_size[0],
                                     settings.SCREEN_SIZE * self.obstacle_size[1], color=settings.OBSTACLE_COLOUR)

        # Draw the goal onto the screen
        arcade.draw_circle_filled(settings.SCREEN_SIZE * self.goal_state[0],
                                  settings.SCREEN_SIZE * self.goal_state[1], settings.SCREEN_SIZE * settings.GOAL_SIZE,
                                  settings.GOAL_COLOUR)

    # The dynamics function, which returns the robot's next state given its current state and current action
    def dynamics(self, robot_state, robot_action):

        # First, set the robot's next state by ignoring the obstacle
        robot_next_state = robot_state + robot_action
        # Then, check if the robot's next state is inside the obstacle
        if robot_next_state[0] > self.obstacle_state[0] - 0.5 * self.obstacle_size[0]:
            if robot_next_state[0] < self.obstacle_state[0] + 0.5 * self.obstacle_size[0]:
                if robot_next_state[1] > self.obstacle_state[1] - 0.5 * self.obstacle_size[1]:
                    if robot_next_state[1] < self.obstacle_state[1] + 0.5 * self.obstacle_size[1]:
                        # The robot's next state is inside the obstacle,
                        # so set the robot's next state to its current state
                        robot_next_state = robot_state
        return robot_next_state
